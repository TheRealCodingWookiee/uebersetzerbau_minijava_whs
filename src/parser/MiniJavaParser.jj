options {
  STATIC = false;
  JAVA_UNICODE_ESCAPE = true;
  DEBUG_PARSER = true;
}

/******************************************************************************/
/* PARSER CODE                                                                */
/******************************************************************************/
PARSER_BEGIN(MiniJavaParser)

  package parser;

  import java.io.*;

  public class MiniJavaParser {

    public static void main(String[] args) {
      try {
         String sourceFilename = args[0];
         FileInputStream in = new FileInputStream(sourceFilename );

         /* parsing of input file */
         new MiniJavaParser(in).Program();
         in.close();
         
         System.out.println("Syntactical analysis successful");   
      }

      catch (ParseException e) {
         System.out.println("Parser Error : \n"+ e.toString());
      } catch (IOException e) {
         System.out.println("File Error : \n"+ e.toString());      
      }
    }
  } 
PARSER_END(MiniJavaParser)


/******************************************************************************/
/* LEXICAL SPECIFICATION                                                      */
/******************************************************************************/

// Definieren Sie hier allezu ignorierenden Tokens.
SKIP : {
        " "
      | "\t"
      | "\n"
      | "\r"
      | "\f"
}

TOKEN : /*KOMMENTARE*/
{
        <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
      | <FORMAL_COMMENT: "/**" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
      | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">

}

// Definieren Sie hier die Tokens der Sprache Minijava.
TOKEN : /*SCHLUESSELWOERTER*/
{
        < LPAREN: "(">
      | < RPAREN: ")">
      | < LSQPAREN: "[">
      | < RSQPAREN: "]">
      | < LBRACE: "{" >
      | < RBRACE: "}" >
      | < SEMICOLON: ";" >
      | < DOT: "." >
      | < ASSIGN: "=" >
      | < LESS_THEN: "<" >
      | < GREATER_THEN: ">">
      | < PLUS: "+" >
      | < MINUS: "-" >
      | < AND : "&&" >
      | < NOT : "!" >
      | < BOOLEAN: "boolean" >
      | < CLASS: "class" >
      | < INTERFACE: "interface" >
      | < ELSE: "else" >
      | < EXTENDS: "extends" >
      | < FALSE: "false" >
      | < IF: "if" >
      | < WHILE: "while" >
      | < INTEGER: "int" >
      | < LENGTH: "length" >
      | < MAIN: "main" >
      | < NEW: "new" >
      | < PUBLIC: "public" >
      | < RETURN: "return" >
      | < STATIC: "static" >
      | < STRING: "String" >
      | < THIS: "this" >
      | < TRUE: "true" >
      | < PRINT: "System.out.println" >
      | < VOID: "void" >
      | < #LETTER: (["a"-"z"] | ["A"-"Z"])+>
      | < #DIGIT: ["0"-"9"]>
      | < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
      | < INTEGER_LITERAL: ( ["1"-"9"] (<DIGIT>)* | "0" ) >
}



/******************************************************************************/
/* SYNTACTICAL SPECIFICATION                                                  */
/******************************************************************************/

/*----------------------------------------------------------------------------
 * Im Folgenden finden Sie eine simple Beispielgrammatik, die Sie anpassen 
 * koennen, um Ihre lexikalische Spezifikation zu testen.
 *----------------------------------------------------------------------------*/

/* Definiert ein Program als eine beliebige Folge von MiniJava-Tokens */
void Program() :
{}
{
    ( Token() )* <EOF>
}

/* Definiert MiniJava-Token als Vereinigung aller oben definierten Tokens */
void Token():
{}
{
    // Geben Sie hier alle in der lexikalischen Spezifikation definierten Tokens 
    // - getrennt durch "|" - ein. Durch die Option "DEBUG_PARSER = true;" (s.o.)
    // zeigt der Parser alle eingelesenen Tokens an.
    //
    (
       <LPAREN> | <RPAREN>
    )
}
